**2019.10.8**

   * [乐观悲观锁，自旋锁。和Synchroynized锁的三种状态](#乐观悲观锁自旋锁和synchroynized锁的三种状态)
      * [乐观和悲观锁](#乐观和悲观锁)
      * [自旋锁](#自旋锁)
      * [偏向锁 轻量级锁 重量级锁](#偏向锁-轻量级锁-重量级锁)
         * [偏向锁：](#偏向锁)
         * [轻量级锁（多核环境）](#轻量级锁多核环境)
      * [Synchroynized和Lock的区别和使用场景](#synchroynized和lock的区别和使用场景)


# 乐观悲观锁，自旋锁。和Synchroynized锁的三种状态
锁按照其种类和场景来划分可以分为很多种锁：

## 乐观和悲观锁
按照读写时候的限制分为悲观锁和乐观锁
**悲观锁** 认为线程在执行的时候都是不安全的，总会有其他来干扰，读和写都进行加锁，其他线程进不来
**乐观锁**读的时候不加锁，写的时候要通过CAS和版本号进行判断。
常见的锁就是Syncrtnized 和renentLock这两者都是悲观锁

悲观锁实现机制：synchroynized LOCK

乐观锁实现机制：ATMOICiNTEGER 通过CAS操作来实现，可能出现ABA问题，解决方法版本号。

## 自旋锁
自旋锁：同样是借助CAS操作来进行实现。常用在多核环境中，未能成功写入的空占有CPU循环等待。避免了线程切换的开销。

## 偏向锁 轻量级锁 重量级锁

在JDK1.7之后引入了偏向锁，轻量级锁，重量级锁的膨胀机制
都是在syncrynized这个锁上面的一些优化

### 偏向锁：
锁的标志位是保存在**对象头**上面的，一个叫做**Mark Word**的东西，一开始设置为的是
偏向锁，即一开始一个线程进入代码块的时候，是如果无锁状态，该对象在对象头中将片将
储存偏向线程的ID.在这个线程退出该代码块后也不释放锁。当这个线程再次进入，只需要对比ID就能直接进入，不需要CAS操作。

但当其他线程也进入该代码块时候，
（1）先检查原有偏向线程是否存活，不存活的话变为无锁状态偏向新的线程。存活进入（2）
（2）如果存活，检查原偏向线程是否还在锁中运行，即是否仍需要锁，如果不需要，换成无锁
状态偏向新线程，如果需要进入（3）:
（3）如果需要的活，原有偏向锁即刻膨胀成轻量级锁

### 轻量级锁（多核环境）
（4）此时被阻塞的线程自旋的获取锁（不阻塞）
（5）当自旋超过一定次数，或者又来了一个线程要获取时候（膨胀为重量级锁）


## Synchroynized和Lock的区别和使用场景
区别：
一个是借助指令monitor监视器实现，一个是借助于AQS搭建的。
一个是关键字，一个是定义的类
syncreynized的释放时自动完成的，而LOCK需要在TRY CATCH中显示的调用UNLOCK
另外，lock还能显示当前线程是否获得了锁 TRYLOCK
使用LOCK的时候可以指定是公平的锁或者不公平的锁。互相竞争

使用场景：LOCK中包括了readWriteLOCK读写锁，限制了写的时候其他锁不能读写




